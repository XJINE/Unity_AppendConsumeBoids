#pragma kernel InitializePool
#pragma kernel UpdateStatus
#pragma kernel EmitAgent
#pragma kernel UpdateForce
#pragma kernel UpdateAgent
#pragma kernel BitonicSort
#pragma kernel UpdateGridIndices

#define THREAD_SIZE_X 256 // or 64, 128

struct BoidsAgent
{
    uint   gridIndex;
    float3 position;
    float3 velocity;
    float  lifeTime;
    int    status;
};

StructuredBuffer  <BoidsAgent> _BoidsAgentBufferRead;
RWStructuredBuffer<BoidsAgent> _BoidsAgentBufferWrite;
StructuredBuffer  <float3>     _BoidsForceBufferRead;
RWStructuredBuffer<float3>     _BoidsForceBufferWrite;
RWStructuredBuffer<uint2>      _GridIndicesBuffer;

StructuredBuffer       <BoidsAgent> _EmitAgentBuffer;
AppendStructuredBuffer <uint>       _PooledAgentBufferAppend; // uint means agent ID
ConsumeStructuredBuffer<uint>       _PooledAgentBufferConsume;

uint  _EmitAgentCount;
uint  _MaxAgentCount;
uint  _AgentCount;
float _MaxAgentSpeed;
float _MaxAgentForce;
float _DeltaTime;

float _SeparateRadius;
float _AlignmentRadius;
float _CohesionRadius;

float _SeparateWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _AvoidWallWeight;

float4 _WallCenter;
float4 _WallSize;
float4 _GridMinCoord;
float4 _GridCellSize;
int3   _GridDivision;
uint   _GridCellCount;
uint   _SortBlockSize;
uint   _SortBlockWidth;
uint   _SortBlockHeight;

int GetGridIndex(float3 position)
{
    float3 localPos  = position - _GridMinCoord.xyz;
    int3   gridCoord = int3(floor(localPos.x / _GridCellSize.x),
                            floor(localPos.y / _GridCellSize.y),
                            floor(localPos.z / _GridCellSize.z));

    gridCoord.x = clamp(gridCoord.x, 0, _GridDivision.x - 1);
    gridCoord.y = clamp(gridCoord.y, 0, _GridDivision.y - 1);
    gridCoord.z = clamp(gridCoord.z, 0, _GridDivision.z - 1);

    return gridCoord.x
         + gridCoord.y * _GridDivision.x
         + gridCoord.z * _GridDivision.x * _GridDivision.y;
}

uint3 GetGridCoordFromIndex(uint gridIndex)
{
    // NOTE:
    // Since gridIndex is calculated as follows.
    // grindIndex = gridCoord.x
    //            + gridCoord.y * _GridDivision.x
    //            + gridCoord.z * _GridDivision.x * _GridDivision.y;

    precise uint3 gridCoord;

    gridCoord.z = gridIndex / (_GridDivision.x * _GridDivision.y);
    gridIndex -= gridCoord.z * _GridDivision.x * _GridDivision.y;
    gridCoord.y = gridIndex / _GridDivision.x;
    gridCoord.x = gridIndex % _GridDivision.x;

    return gridCoord;
}

uint GetGridIndexFromCoord(uint3 gridCoord)
{
    gridCoord.x = clamp(gridCoord.x, 0, _GridDivision.x - 1);
    gridCoord.y = clamp(gridCoord.y, 0, _GridDivision.y - 1);
    gridCoord.z = clamp(gridCoord.z, 0, _GridDivision.z - 1);
    
    return gridCoord.x
         + gridCoord.y * _GridDivision.x
         + gridCoord.z * _GridDivision.x * _GridDivision.y;
}

float3 Limit(float3 vec, float max)
{
    float len = length(vec);
    return max < len && 0 < len ? vec.xyz * (max / len) : vec.xyz;
}

float3 AvoidWall(float3 position)
{
    float3 center = _WallCenter.xyz;
    float3 size   = _WallSize.xyz;
    float3 force  = 0;

    force.x += (position.x < center.x - size.x * 0.5) ? + 1.0 : 0;
    force.x += (position.x > center.x + size.x * 0.5) ? - 1.0 : 0;

    force.y += (position.y < center.y - size.y * 0.5) ? + 1.0 : 0;
    force.y += (position.y > center.y + size.y * 0.5) ? - 1.0 : 0;

    force.z += (position.z < center.z - size.z * 0.5) ? + 1.0 : 0;
    force.z += (position.z > center.z + size.z * 0.5) ? - 1.0 : 0;

    return force;
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void InitializePool(uint3 dtId : SV_DispatchThreadID)
{
    if(_MaxAgentCount <= dtId.x)
    {
        return;
    }

    _PooledAgentBufferAppend.Append(dtId.x);
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void BitonicSort(uint3 dtId : SV_DispatchThreadID) // in-place sorting
{
    if (_AgentCount <= dtId.x)
    {
        return;
    }

    uint index  = dtId.x;
    uint index2 = index ^ _SortBlockSize;

    if (index < index2 && index2 < _AgentCount)
    {
        BoidsAgent agent1 = _BoidsAgentBufferWrite[index];
        BoidsAgent agent2 = _BoidsAgentBufferWrite[index2];

        uint gridIndex1 = agent1.gridIndex;
        uint gridIndex2 = agent2.gridIndex;

        uint blockIndex = index / _SortBlockWidth;
        bool ascending  = (blockIndex % 2) == 0; // even -> ascending, odd -> descending
        bool shouldSwap = false;

        if (gridIndex1 != gridIndex2)
        {
            shouldSwap = ascending ? (gridIndex1 > gridIndex2) : (gridIndex1 < gridIndex2);
        }

        if (shouldSwap)
        {
            _BoidsAgentBufferWrite[index]  = agent2;
            _BoidsAgentBufferWrite[index2] = agent1;
        }
    }
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void UpdateGridIndices(uint3 dtId : SV_DispatchThreadID)
{
    if (_AgentCount <= dtId.x)
    {
        return;
    }

    uint agentIndex       = dtId.x;
    uint currentGridIndex = _BoidsAgentBufferRead[agentIndex].gridIndex;
    bool startGridIndex   = agentIndex == 0 || _BoidsAgentBufferRead[agentIndex - 1].gridIndex != currentGridIndex;

    if(!startGridIndex) // check 0 or previous index is different.
    {
        return;
    }

    uint endGridIndex = agentIndex;

    for (uint i = agentIndex + 1; i < _AgentCount; i++)
    {
        if (_BoidsAgentBufferRead[i].gridIndex == currentGridIndex)
        {
            endGridIndex = i;
        }
        else
        {
            break;
        }
    }

    // Set grid indices range for this grid cell
    if (currentGridIndex < _GridCellCount)
    {
        _GridIndicesBuffer[currentGridIndex] = uint2(agentIndex, endGridIndex);
    }
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void UpdateStatus(uint3 dtId : SV_DispatchThreadID)
{
    const uint agentId = dtId.x;

    if(_MaxAgentCount <= agentId)
    {
        return;
    }

    BoidsAgent agent = _BoidsAgentBufferWrite[agentId];

    if (0 < agent.lifeTime)
    {
        agent.lifeTime = agent.lifeTime - _DeltaTime;
        agent.status   = 0 < agent.lifeTime ? 1 : 0;

        _BoidsAgentBufferWrite[agentId] = agent;

        if (agent.status == 0)
        {
            _PooledAgentBufferAppend.Append(agentId);
        }
    }
    else if (agent.status == 1)
    {
        // Handle agents with lifeTime <= 0 that are still marked as active
        // This ensures they are returned to the pool
        agent.status = 0;
        _BoidsAgentBufferWrite[agentId] = agent;
        _PooledAgentBufferAppend.Append(agentId);
    }
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void EmitAgent(uint3 dtId : SV_DispatchThreadID)
{
    if(_EmitAgentCount <= dtId.x)
    {
        return;
    }

    BoidsAgent agent   = _EmitAgentBuffer[dtId.x];
    uint       agentId = _PooledAgentBufferConsume.Consume();

    agent.gridIndex = GetGridIndex(agent.position);

    _BoidsAgentBufferWrite[agentId] = agent;
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void UpdateForce(uint3 dtId : SV_DispatchThreadID)
{
    if(_MaxAgentCount <= dtId.x)
    {
        return;
    }

    uint agentId = dtId.x;

    if(_BoidsAgentBufferRead[agentId].status == 0)
    {
        return;
    }

    float3 P_position = _BoidsAgentBufferRead[agentId].position;
    float3 P_velocity = _BoidsAgentBufferRead[agentId].velocity;
    uint   P_gridIndex = _BoidsAgentBufferRead[agentId].gridIndex;
    int3   P_gridCoord = GetGridCoordFromIndex(P_gridIndex);

    float3 sepPosSum = 0;
    float3 aliVelSum = 0;
    float3 cohPosSum = 0;

    int sepCount = 0;
    int aliCount = 0;
    int cohCount = 0;

    for (int dZ = -1; dZ <= 1; dZ++){
    for (int dY = -1; dY <= 1; dY++){
    for (int dX = -1; dX <= 1; dX++)
    {
        int3 N_gridCoord = P_gridCoord + int3(dX, dY, dZ);
        uint N_gridIndex = GetGridIndexFromCoord(N_gridCoord);

        uint2 gridIndices = _GridIndicesBuffer[N_gridIndex];
        uint  startIndex  = gridIndices.x;
        uint  endIndex    = gridIndices.y;

        if (startIndex == 0xFFFFFFFF || endIndex == 0xFFFFFFFF) // 0xFFFFFFFF means max uint value.
        {
            continue;
        }
        
        // Sample neighboring agents in this grid cell
        for (uint i = startIndex; i <= endIndex && i < _AgentCount; i++)
        {
            BoidsAgent neighbor = _BoidsAgentBufferRead[i];

            if(neighbor.status == 0)
            {
                continue;
            }

            float3 N_position = neighbor.position;
            float3 N_velocity = neighbor.velocity;
            float3 diff       = P_position - N_position;
            float  dist       = length(diff);

            // Separate
            if (0.0 < dist && dist <= _SeparateRadius)
            {
                float3 repulse = normalize(diff) / dist;
                sepPosSum += repulse;
                sepCount  += 1;
            }

            // Alignment
            if (0.0 < dist && dist <= _AlignmentRadius)
            {
                aliVelSum += N_velocity;
                aliCount  += 1;
            }

            // Cohesion
            if (dist > 0.0 && dist <= _CohesionRadius)
            {
                cohPosSum += N_position;
                cohCount  += 1;
            }
        }
    }}}

    float3 force    = 0;
    float3 sepForce = 0;
    float3 aliForce = 0;
    float3 cohForce = 0;

    // Separate
    if (0 < sepCount)
    {
        sepForce = sepPosSum / (float)sepCount;
        sepForce = normalize(sepForce) * _MaxAgentSpeed;
        sepForce = sepForce - P_velocity;
        sepForce = Limit(sepForce, _MaxAgentForce);
    }

    // Alignment
    if (0 < aliCount)
    {
        aliForce = aliVelSum / (float)aliCount;
        aliForce = normalize(aliForce) * _MaxAgentSpeed;
        aliForce = aliForce - P_velocity;
        aliForce = Limit(aliForce, _MaxAgentForce);
    }

    // Cohesion
    if (0 < cohCount)
    {
        cohPosSum = cohPosSum / (float)cohCount;
        cohForce  = cohPosSum - P_position;
        cohForce  = normalize(cohForce) * _MaxAgentSpeed;
        cohForce  = cohForce - P_velocity;
        cohForce  = Limit(cohForce, _MaxAgentForce);
    }

    force += aliForce * _AlignmentWeight;
    force += cohForce * _CohesionWeight;
    force += sepForce * _SeparateWeight;

    _BoidsForceBufferWrite[agentId] = force;
}

[numthreads(THREAD_SIZE_X, 1, 1)]
void UpdateAgent(uint3 dtId : SV_DispatchThreadID)
{
    if(_MaxAgentCount <= dtId.x)
    {
        return;
    }

    uint       agentId = dtId.x;
    BoidsAgent agent   = _BoidsAgentBufferWrite[agentId];

    if(agent.status == 0)
    {
        return;
    }

    float3 force  = _BoidsForceBufferRead[agentId];
           force += AvoidWall(agent.position) * _AvoidWallWeight;

    agent.gridIndex = GetGridIndex(agent.position);
    agent.velocity += force * _DeltaTime;
    agent.velocity  = Limit(agent.velocity, _MaxAgentSpeed);
    agent.position += agent.velocity * _DeltaTime;

    _BoidsAgentBufferWrite[agentId] = agent;
}